{"meta":{"title":"My Technology Blog","subtitle":"Tech blogging site","description":null,"author":"Pierce Primm, Sr.","url":"http://pprimm.github.io"},"pages":[{"title":"About","date":"2016-10-03T00:10:02.693Z","updated":"2016-10-03T00:10:02.693Z","comments":true,"path":"about/index.html","permalink":"http://pprimm.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-03T00:10:02.695Z","updated":"2016-10-03T00:10:02.695Z","comments":true,"path":"categories/index.html","permalink":"http://pprimm.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-10-03T00:10:02.697Z","updated":"2016-10-03T00:10:02.697Z","comments":true,"path":"tags/index.html","permalink":"http://pprimm.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Home Security Sytetm using Raspberry Pi Zero and deepstreamHub","slug":"DeepstreamHub-alarm-system","date":"2017-11-01T00:44:14.000Z","updated":"2017-12-26T19:19:00.000Z","comments":true,"path":"2017/10/31/DeepstreamHub-alarm-system/","link":"","permalink":"http://pprimm.github.io/2017/10/31/DeepstreamHub-alarm-system/","excerpt":"What is this?This project is a submission to the deepstreamHub Contest, Sept. 2017. It is a realtime mobile UI demo demonstrating how to use the deepstream JavaScript client to interact with a home security system through deepstreamHub. Here is the main repository for the project. The companion project is a security system simulator that demonstrates how to create a provider for deepstreamHub using NodeJS and the same deepstream JavaScript client as the UI. Home Security App running in Safari on iPhone 6","text":"What is this?This project is a submission to the deepstreamHub Contest, Sept. 2017. It is a realtime mobile UI demo demonstrating how to use the deepstream JavaScript client to interact with a home security system through deepstreamHub. Here is the main repository for the project. The companion project is a security system simulator that demonstrates how to create a provider for deepstreamHub using NodeJS and the same deepstream JavaScript client as the UI. Home Security App running in Safari on iPhone 6A build is running at https://pprimm.github.io/ds-contest-material/. The app will not be responsive to user actions if the provider (mentioned) above is not running and connected to DeepstreamHub. Here’s how to use the app: After logging in, you’ll see the main Alarm System page which shows the system status (ie. Not Armed, Armed Away, etc.), the buttons used to arm/disarm and the overall status summary of the security zones. In order for the system to be ready to arm, all zones must be Ready or Bypassed if Open or in Trouble. Arm Away will countdown ten (10) seconds, then arm. Arm Stay will arm immediately. To view the zones list, select the ZONES button in the top right; you’ll be taken to the zones list page. From here you can make selections on the top tab bar for filtering the zones you see by their status. You can tap a zone item to cycle it’s status through Ready, Open and Trouble. To bypass a zone, tap the toggle control. The arm buttons will be disabled if any zones are Open or in Trouble. It’s easy to tap the OPEN or TROUBLE tabs to bypass these zone(s). You can also open multiple instances and see the effect that changing the zone status and/or bypassing zones has on the filtered zones list and the main Alarm System status page. Disclaimer: This project is NOT designed to be referenced as best practices. Why is it here?Well, the obvious reason is that it was created as a submission to the aforementioned design contest. But, there’s a bit of background here. I have been playing with using React/cerebral to create UX for home automation for a few months. My original tech stack used MQTT over Web-sockets for real-time transport. This worked pretty well because my back-end control system is MQTT driven. However, I wanted to test an abstraction that allowed for more productivity and ease-of-design on the front-end; in other words, deepstream would be used for the front-end channel to separate/decouple messaging. Anyhoo, the contest gave me the opportunity (interpret: the motivation) to produce a limited-scope solution to test deepstream in this scenario. Tech Stack deepstreamHub &amp; deepstream javascript client React Cerebral for React for state management, effects and routing Material UI to ease the UI design burden A Brief Architectural Overview (Commentary) Warning: this is opionated. The concepts of React and Flux have made significant impacts on the dev community over the past few years. Specifically, the state/action flow of Flux helped to shape perceptions of uni-directional flow. I wanted to solve the problem of this particular contest (Realtime Security System) with what I term “full-stack-flux”; basically, flux concept from the front-end to back-end. Please allow me to try and explain further. The View is React; so from that standpoint, we’re on-par with standard Flux. From there we indroduce the concepts of Signals, Actions and State which come from the Cerebral project. Signals are triggered from both user interaction and the back-end and then, in turn, trigger Actions that either update the local UI State or send the action on to the back-end for processing. It may be important to note that the Actions triggered by Signals are composable and provide a needed abstraction layer. The pure UI has no idea of front-end or back-end state changes or processing, doesn’t care and ideally hold no state of its own. The deepstreamHub provider listens for Actions (pub-sub Events in deepstream) coming from the front end and/or other back-end services. The Actions received are processed and may or may not produce a change in state (Records in deepstream). These Record(s) changes then trigger Signals to be processed on the front-end as described above. The flow is extremely easy to reason about. To give a concrete example “event” from our app, we’ll follow a progression that takes place when the user “taps” on a zone to toggle the zone bypass. So, here’s what takes place: The user taps a toggle control on a particular security zone (the &lt;Switch&gt; component in the higher-order &lt;ZoneListItem&gt; component). The components onChange() event calls a bypassPressed signal with the ID of the zone. This is the last the UI knows of the process. Though Cerebral, the signal calls the single bypassPressed action (it could call many actions that update both UI and call back-end actions independently). The bypassPress action calls the action(...) function on the deepstream provider; which ultimately performs a pub-sub event call to deepstreamHub. On the back-end, the deepstreamHub provider (written in NodeJS…our security system simulator) receives the pub-sub event because it is appropriately subscribed to the event. The simulator processes and validate the Event and, in this case, toggles the bypass property, if you will, in the appropriate Record and performs other processing now that the zone has been bypassed by the user. This action then triggers multiple actions like: if the bypassed zone was keeping the system from going to the ready state, the system could then move to the ready state. Because this is also a state change, the appropriate record would be updated and things would progress similarly as described below. Back on the front-end, Cerebral deepstreamHub provider is subscribed to received changes to that record, so it received this update and then triggers the, you guessed it, dsUpdate Signal which calls the dsUpdate Action. The dsUpdate Action the modifies the appropriate Crerebral state; this, in turn, triggers the UI updates because the appropriate components are “subscribed” to that portion of the state tree. AND, voilà, the user sees the toggle control change state (and any other state changes that occurred because of the simulator updates). Possible Improvements (what I would do from here if this were a real app)There are many improvement that could be made to make this app better. Improvements to structure, naming convention, etc. would be a first step. Really, this app was slung together quickly in order to meet a deadline for contest entry. So, here are some things I would do if this were a real app: Add DeepstreamHub User Authorization and Permissions. Obvious permissions would be to prevent UI client(s) from modifying Records in any way because these client should only be able to trigger Actions (as described above) and prevent them from listening to corresponding Actions. Refactor React code. Possibly add styled-components (‘cause I love it). I am not a front-end coder and not very experienced in HTML/CSS; there is likely A LOT of room for improvement here. Refactor deepstream client provider by adding a deepstream cerebral module to handle interaction between the app and the deepstream client cerebral provider. In addition to exposing the core deepstream client api through the provider in a cerebral-ish way, a signal/action/state behavior layer might be exposed as well. Analyze refactoring the cerebral app state by investigating the effects/boundaries of separating ui specific state from device specific state. Effects here would be very beneficial in a large app with many pages/state/user interactions. Analyze ramifications of multiple users performing multiple actions at the same time (address scaling). Improve the UX (highly subjective, but, this UX is marginal) The back-end device would be based on a real security system implementation to the API could change dramatically. This project was bootstrapped with Create React App. Below you will find some information on how to perform common tasks. You can find the most recent version of this guide here.","categories":[{"name":"Project","slug":"Project","permalink":"http://pprimm.github.io/categories/Project/"}],"tags":[{"name":"Raspberry Pi Zero","slug":"Raspberry-Pi-Zero","permalink":"http://pprimm.github.io/tags/Raspberry-Pi-Zero/"},{"name":"Raspbian Jessie Lite","slug":"Raspbian-Jessie-Lite","permalink":"http://pprimm.github.io/tags/Raspbian-Jessie-Lite/"},{"name":"IoT","slug":"IoT","permalink":"http://pprimm.github.io/tags/IoT/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://pprimm.github.io/tags/NodeJS/"},{"name":"Home Automation","slug":"Home-Automation","permalink":"http://pprimm.github.io/tags/Home-Automation/"},{"name":"Home Security","slug":"Home-Security","permalink":"http://pprimm.github.io/tags/Home-Security/"}]},{"title":"Headless Raspberry Pi Zero - Setup Wifi Directly on an SDHC Card on Windows 8","slug":"Pi-Zero-Headless-Wifi","date":"2016-10-04T02:21:57.000Z","updated":"2016-10-08T01:05:00.000Z","comments":true,"path":"2016/10/03/Pi-Zero-Headless-Wifi/","link":"","permalink":"http://pprimm.github.io/2016/10/03/Pi-Zero-Headless-Wifi/","excerpt":"This tutorial is a follow-up (or addendum, if you will) to Headless Raspberry Pi Zero Setup with Ethernet from Ground Zero on Windows 8 which shows how to get a Pi Zero running and connected to a network without using a monitor, keyboard or mouse. In this follow-up tutorial, we are going to address getting a Pi Zero running with only a Wifi dongle. This is only ONE way to do this. Your mileage may vary.","text":"This tutorial is a follow-up (or addendum, if you will) to Headless Raspberry Pi Zero Setup with Ethernet from Ground Zero on Windows 8 which shows how to get a Pi Zero running and connected to a network without using a monitor, keyboard or mouse. In this follow-up tutorial, we are going to address getting a Pi Zero running with only a Wifi dongle. This is only ONE way to do this. Your mileage may vary. Equipment You’ll Need Your Windows 8 PC with SD interface or adapter Pi Zero $5 buy Blank 8GB microSDHC w/Adapter $7.50 buy Tiny OTG Adapter $2.95 buy Wifi Dongle Adafruit $11.95 or Amazon $9 5V 2.4A Switching Power Supply w/ 20AWG 6’ MicroUSB Cable $7.95 or equivalent buy (Optional) Adafruit Pi Protector buy Software You’ll Need Paragon ExtFS for Windows download Initial SetupFirst, follow steps 1 - 4 in the Install Raspbian Jessie Lite on 8GB microSDHC Card section of my previous Headless Raspberry Pi Zero Setup post. Then, come back and perform the steps below for setting the wifi SSID and password. You can then jump back to the original post and continue with the Boot the Pi Zero and Connect with PuTTY section. Setting the Wifi SSID and PasswordOnce we have the Raspbian Jessie Lite image on our SDHC card, we can edit the _wpasupplicant.conf file using ExtFS for Windows. The basic steps for this process were derived the Pi Help topic post: Setting Wifi Up via the Command Line. So, follow these easy steps to make the appropriate modification(s) to this file: Download and install ExtFS for Windows. After I installed ExtFS on my Windows 8 box, a driver icon showed up in the system tray. Although this tool can create and modify partitions (and other things), we’re just using it to access the file system and modify a file. With the SDHC Card plugged into your reader, double-click on the ExtFS icon that is in your system tray. You should see something like this: ExtFS, if properly installed, should recognize the Ext volume and automatically mount as a drive letter in Windows Explorer. You can select the volume and mount/un-mount. When you do, it will appear/disappear as a drive letter. As you can see from the above screen capture, the SDHC card has mounted the Ext volume to drive letter [F:]. The “raw” SDHC card will show up in Explorer as a separate drive letter; mine was drive [E:]. BONUS: Since we have the SDHC card mounted as a drive, we can take this opportunity to quickly do large file transfers for the Pi to access later. (Tip provided by Daniel Buentello) We’re now going to modify the file [\\etc\\wpa_supplicant\\wpa_supplicant.conf]. In Windows Explorer, go to the [\\etc\\wpa_supplicant] folder and open the [wpa_supplicant.conf] file with an appropriate editor. I use the Atom Editor. When I open the file for editing in Atom, the filed contents look like this: 123country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1 I don’t care to make any changes here. We want to go to the bottom of the file (after the update_config=1 line) and add the following (obviously, modifying it to contain your specific SSID and password): 1234network=&#123; ssid=\"your-ssid\" psk=\"your-password\"&#125; Now, just save and close the file. Eject the SDHC card from your system. I didn’t have to un-mount the volume in ExtFS before ejecting the SDCH card as this is a setting in ExtFS. Now you can pickup with the Boot the Pi Zero and Connect with PuTTY section from the original post. Good luck and I hope this helps you get your headless Pi Zero up and running with a Wifi dongle.","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"http://pprimm.github.io/categories/Tutorial/"}],"tags":[{"name":"Raspberry Pi Zero","slug":"Raspberry-Pi-Zero","permalink":"http://pprimm.github.io/tags/Raspberry-Pi-Zero/"},{"name":"Raspbian Jessie Lite","slug":"Raspbian-Jessie-Lite","permalink":"http://pprimm.github.io/tags/Raspbian-Jessie-Lite/"},{"name":"IoT","slug":"IoT","permalink":"http://pprimm.github.io/tags/IoT/"},{"name":"Headless Wifi","slug":"Headless-Wifi","permalink":"http://pprimm.github.io/tags/Headless-Wifi/"}]},{"title":"Headless Raspberry Pi Zero Setup with Ethernet from Ground Zero on Windows 8","slug":"Pi-Zero-from-Ground-Zero","date":"2016-10-03T00:44:14.000Z","updated":"2016-10-08T01:05:00.000Z","comments":true,"path":"2016/10/02/Pi-Zero-from-Ground-Zero/","link":"","permalink":"http://pprimm.github.io/2016/10/02/Pi-Zero-from-Ground-Zero/","excerpt":"I love the idea of using the Raspberry Pi Zero as a headless home automation IoT appliance. Actually, using multiple Zero(s) to run independent NodeJS services sounds very appealing. I’ve been wanting to do something like this for years. The main thing that kept me from my plan to have my house running completely on the Raspberry Pi platform was my inability to easily and effectively setup a Pi for NodeJS; particularly, the Pi Zero due to its no on-board network interface. I wanted to be able to start with a blank microSDHC and end up with an SSH enabled device connected to the network and running NodeJS without needing a keyboard and monitor during the process. Here’s what I do to get my headless Zero(s) up and running in a very short amount of time.","text":"I love the idea of using the Raspberry Pi Zero as a headless home automation IoT appliance. Actually, using multiple Zero(s) to run independent NodeJS services sounds very appealing. I’ve been wanting to do something like this for years. The main thing that kept me from my plan to have my house running completely on the Raspberry Pi platform was my inability to easily and effectively setup a Pi for NodeJS; particularly, the Pi Zero due to its no on-board network interface. I wanted to be able to start with a blank microSDHC and end up with an SSH enabled device connected to the network and running NodeJS without needing a keyboard and monitor during the process. Here’s what I do to get my headless Zero(s) up and running in a very short amount of time.Please refer to the following component descriptions during this tutorial: Image courtesy cdn-reichelt.de and may be subject copyright Equipment You’ll Need Your Windows 8 PC with SD interface or adapter Pi Zero $5 buy Blank 8GB microSDHC w/Adapter $7.50 buy Micro USB OTG Ethernet with 3 Port Hub $16.00 buy I like this unit because it is supplied with a USB power-only cord and can be externally powered as well as USB powered. This also supplies power to our Pi Zero; which is a plus. 5V 2A USB Power Supply $6.95 or equivalent buy (Optional) Adafruit Pi Protector buy If you want to purchase a microSDHC card with Jessie Lite already on it, get it here and skip straight to section Boot the Pi Zero and Connect with PuTTY. Updated 2016-10-03: I added a very short tutorial for using a Wifi dongle instead of the USB Ethernet adapter like the one above. If you want go wireless instead of using wired Ethernet, see the wifi post. The wifi tutorial shows only the steps needed to configure the wifi. You will still need to follow all the steps in this tutorial. I’ll make a note below as to when it’s appropriate to jump to the wifi tutorial. Given that a Pi 3 is $40+ with power adapters, etc., it’s a good way to go when you don’t need a quad-core and 1G RAM. Software You’ll Need Raspbian Jessie Lite download Extract the .img file SDFormatter download Win32 Disk Imager download PuTTY download What We’re Going To Do Install Raspbian Jessie Lite on 8GB microSDHC Card Boot the Pi Zero and Connect with PuTTY Install Git and NodeJS Install Raspbian Jessie Lite on 8GB microSDHC CardFollow these simple steps to prepare your microSC Card: Download Raspbian Jessie Lite image in zip file format. download Extract the 2016-05-27-raspbian-jessie-lite.img file. The 2016-05-27 was the release at the time of this writing. Format the SD card with SDFormatter. Be sure the select the FORMAT SIZE ADJUSTMENT: ON like this: INSURE YOU HAVE SELECTED THE CORRECT DRIVE LETTER Run Win32 Disk Imager as administrator and write the 2016-05-27-raspbian-jessie-lite.img file to the SD Card. AGAIN, INSURE YOU HAVE SELECTED THE CORRECT DRIVE LETTER Carl Recktenwald Jr. has a YouTube Video that shows using SDFormatter and Win32 Disk Imager. You can watch up to 2:30 where then begins a boot using monitor, keyboard and mouse. But, we’re going headless, so the remainder of that video doesn’t pertain to what we’re trying to accomplish. Running with Wifi: If you want to use a wifi dongle instead of the Ethernet adapter, perform the steps in my wifi tutorial now. Then, come back and continue with the next section for booting the Pi Zero. Boot the Pi Zero and Connect with PuTTYFollow these steps to boot and connect to your Pi Zero over SSH: Insert the newly ripped SD Card in your Pi Zero. The Card holder is just an interference fit socket; so, is doesn’t click or have the bounce-in/out function like some other Pi(s). Connect the Micro USB Ethernet USB-HUB to the Zero’s Micro USB Data Port. Make sure you are connecting to the data port and not the power-only port. Refer to picture above. Use the Ethernet adapter’s power cord to power the adapter and Pi Zero. Jessie should automatically, by default, find the USB to Ethernet adapter, connect to the network and obtain an IP via DHCP. After giving the Pi Zero a few minutes to perform the first boot, try to connect over SSH using PuTTY. The easiest method, if it works, is to rely on the Bonjour Service which should be enabled on Windows 8 or exist because you are using an Apple piece of software that relies on Bonjour. Try connecting over SSH using pi@raspberrypi.local on port 22. If connecting using the local domain works and PuTTY is connecting to the Pi Zero host for the first time, then you will see something like this: If you don’t see the above warning or PuTTY gives you an error message that it can’t open the connection, go to the [Finding Your Pi Zero’s IP] section below. This section provides several methods for finding the IP of your PI Zero.However, if you see this window, select [Yes] to continue and you will be presented with the login prompt. The default password is [raspberry] (without the [ ]). Once you login, you should see something like this: Open the Configuration Tool and make any changes you would like. You do this by entering the following command in PuTTY terminal: 1$ sudo raspi-config Updated 2016-10-03: A RasPi user notified me that starting with Jessie 2016-05-10, a script will auto-expand the file system on first boot. You don’t need to perform this step. But, if you are interested in bringing up the Configuration Tool and looking around, you can go ahead and continue as a learning exercise; otherwise, jump down to step 5. Executing this command show you the configuration tool. The only configuration item we’re going to do now is expand the file system. Select the fist item [1. Expand Filesystem] and select [Enter]. The filesystem will be expanded to used the full size of the SD Card. Now, just scroll down and select [Finish]. If you are asked to reboot, say Yes. You will be logged off and PuTTY will disconnect. Give the Pi Zero time to reboot. Then, reconnect with PuTTY and continue to the next step. Perform Jessie updates by entering the following two (2) commands in the terminal; allowing a command to complete before continuing to the next. 12$ sudo apt-get update$ sudo apt-get upgrade Install Git and NodeJSNow we’re going to install Git and NodeJs. Perform these steps: Install Git using the following command: 1$ sudo apt-get install git Install NodeJS using the following commands; allowing each to complete: 12345$ wget https://nodejs.org/dist/v4.5.0/node-v4.5.0-linux-armv6l.tar.gz$ tar -xvf node-v4.5.0-linux-armv6l.tar.gz$ cd node-v4.5.0-linux-armv6l$ sudo cp -R * /usr/local/$ sudo reboot After reboot, re-login and execute the following command to verify the NodeJS install. 12$ node --versionv4.5.0 Now we have a Raspberry Pi Zero connected to our network and running NodeJS; ready to clone a repository and get to work. I hope this is useful for you. Finding Your Pi Zero’s IP (if raspberrypi.local doesn’t work)We need to perform this step only if PuTTY can’t connect using [pi@raspberrypi.local]. In that case, there are several methods we can use to find the IP of our Pi Zero. Try one of these methods: One of the easiest methods is to login to your router and look at the list of connected hosts. This might give a clue as to the new IP; especially if the raspberrypi name is listed or your other hosts are listed by name. If it’s not clear what the IP is, then try another method. If you have an IP scanner, use it. Chances are, if you have an IP scanner, you know how to use it and you are used to finding IPs of unknown hosts using this method. We’re looking for an open port 22. So, if your scanner supports particular port scans, this will focus the scan and likely give better results. Use an nmap scan download. Go to the nmap download page and scroll down to Microsoft Windows binaries and locate [nmap-7.30-setup.exe]. Download and install. This is the Zenmap GUI for Windows. Run the program and enter [nmap -p 22 10.10.101.0/24] in the command field as shown here (replacing my LAN IP, 10.10.101.0 in this case, with yours). The Target field will be filled in automatically. Select Scan and review the results in the [Nmap Output] tab. You are looking for an open port 22 like this: Yay! We found the Pi Zero at IP 10.10.101.43. Write down your IP for future reference. Then, go back to the boot section, item 3 and continue with the setup.","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"http://pprimm.github.io/categories/Tutorial/"}],"tags":[{"name":"Raspberry Pi Zero","slug":"Raspberry-Pi-Zero","permalink":"http://pprimm.github.io/tags/Raspberry-Pi-Zero/"},{"name":"Raspbian Jessie Lite","slug":"Raspbian-Jessie-Lite","permalink":"http://pprimm.github.io/tags/Raspbian-Jessie-Lite/"},{"name":"IoT","slug":"IoT","permalink":"http://pprimm.github.io/tags/IoT/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://pprimm.github.io/tags/NodeJS/"},{"name":"Headless Ethernet","slug":"Headless-Ethernet","permalink":"http://pprimm.github.io/tags/Headless-Ethernet/"}]}]}